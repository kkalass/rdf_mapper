<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="description" content="rdf_mapper API docs, for the Dart programming language.">
  <title>rdf_mapper - Dart API docs</title>


  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet">
  
  <link rel="stylesheet" href="static-assets/github.css?v1">
  <link rel="stylesheet" href="static-assets/styles.css?v1">
  <link rel="icon" href="static-assets/favicon.png?v1">
  
</head>

<body data-base-href="" data-using-base-href="false" class="light-theme">
<div id="overlay-under-drawer"></div>
<header id="title">
  <span id="sidenav-left-toggle" class="material-symbols-outlined" role="button" tabindex="0">menu</span>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="https://kkalass.github.io/rdf_mapper/">rdf_mapper package</a></li>
  </ol>
  <div class="self-name">rdf_mapper</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
  <button class="toggle" id="theme-button" title="Toggle between light and dark mode" aria-label="Light and dark mode toggle">
    <span id="dark-theme-button" class="material-symbols-outlined" aria-hidden="true">
      dark_mode
    </span>
    <span id="light-theme-button" class="material-symbols-outlined" aria-hidden="true">
      light_mode
    </span>
  </button>
</header>
<main>
  <div id="dartdoc-main-content" class="main-content">
      
<section class="desc markdown">
  <h1 id="rdf-mapper-for-dart">RDF Mapper for Dart</h1>
<p><a href="https://pub.dev/packages/rdf_mapper"><img src="https://img.shields.io/pub/v/rdf_mapper.svg" alt="pub package"></a>
<a href="https://github.com/kkalass/rdf_mapper/actions"><img src="https://github.com/kkalass/rdf_mapper/actions/workflows/ci.yml/badge.svg" alt="build"></a>
<a href="https://codecov.io/gh/kkalass/rdf_mapper"><img src="https://codecov.io/gh/kkalass/rdf_mapper/branch/main/graph/badge.svg" alt="codecov"></a>
<a href="https://github.com/kkalass/rdf_mapper/blob/main/LICENSE"><img src="https://img.shields.io/github/license/kkalass/rdf_mapper.svg" alt="license"></a></p>
<p>A powerful library for bidirectional mapping between Dart objects and RDF (Resource Description Framework), built on top of <a href="https://pub.dev/packages/rdf_core"><code>rdf_core</code></a>.</p>
<h2 id="overview">Overview</h2>
<p><a href="https://kkalass.github.io/rdf_mapper/">üåê <strong>Official Homepage</strong></a></p>
<p><code>rdf_mapper</code> provides an elegant solution for transforming between Dart object models and RDF graphs, similar to an ORM for databases. This enables developers to work with semantic data in an object-oriented manner without manually managing the complexity of transforming between dart objects and RDF triples.</p>
<blockquote>
<p><strong>üéØ New: Code Generation Available!</strong><br>
For the ultimate developer experience, use our <strong>annotation-driven code generation</strong> with <a href="https://pub.dev/packages/rdf_mapper_annotations"><code>rdf_mapper_annotations</code></a> and <a href="https://pub.dev/packages/rdf_mapper_generator"><code>rdf_mapper_generator</code></a>. Simply annotate your classes, run <code>dart run build_runner build</code>, and get type-safe, zero-boilerplate RDF mappers automatically generated!</p>
</blockquote>
<hr>
<h2 id="part-of-a-whole-family-of-projects">Part of a whole family of projects</h2>
<p>If you are looking for more rdf-related functionality, have a look at our companion projects:</p>
<ul>
<li><strong>Easy code generation</strong>: <a href="https://github.com/kkalass/rdf_mapper_annotations">rdf_mapper_annotations</a> + <a href="https://github.com/kkalass/rdf_mapper_generator">rdf_mapper_generator</a> - Generate type-safe mappers with zero boilerplate using annotations</li>
<li>basic graph classes as well as turtle/jsonld/n-triple encoding and decoding: <a href="https://github.com/kkalass/rdf_core">rdf_core</a></li>
<li>encode and decode rdf/xml format: <a href="https://github.com/kkalass/rdf_xml">rdf_xml</a></li>
<li>easy-to-use constants for many well-known vocabularies: <a href="https://github.com/kkalass/rdf_vocabularies">rdf_vocabularies</a></li>
<li>generate your own easy-to-use constants for other vocabularies with a build_runner: <a href="https://github.com/kkalass/rdf_vocabulary_to_dart">rdf_vocabulary_to_dart</a></li>
</ul>
<hr>
<h2 id="-key-features">‚ú® Key Features</h2>
<ul>
<li><strong>Bidirectional Mapping</strong>: Seamless conversion between Dart objects and RDF representations</li>
<li><strong>Type-Safe</strong>: Fully typed API for safe RDF mapping operations</li>
<li><strong>Code Generation</strong>: Zero-boilerplate mapping with <a href="https://pub.dev/packages/rdf_mapper_generator"><code>rdf_mapper_generator</code></a> - annotate your classes and get optimized mappers automatically</li>
<li><strong>Extensible</strong>: Easy creation of custom mappers for domain-specific types</li>
<li><strong>Flexible</strong>: Support for all core RDF concepts: IRI nodes, blank nodes, and literals</li>
<li><strong>Dual API</strong>: Work with RDF strings or directly with graph structures</li>
</ul>
<h2 id="what-is-rdf">What is RDF?</h2>
<p>Resource Description Framework (RDF) is a standard model for data interchange on the Web. It extends the linking structure of the Web by using URIs to name relationships between things as well as the two ends of the link.</p>
<p>RDF is built around statements known as "triples" in the form of subject-predicate-object:</p>
<ul>
<li><strong>Subject</strong>: The resource being described (identified by an IRI or blank node)</li>
<li><strong>Predicate</strong>: The property or relationship (always an IRI)</li>
<li><strong>Object</strong>: The value or related resource (an IRI, blank node, or literal value)</li>
</ul>
<h2 id="installation">Installation</h2>
<p>Add the following to your <code>pubspec.yaml</code>:</p>
<pre class="language-yaml"><code class="language-yaml">dependencies:
  rdf_mapper: ^0.8.8
</code></pre>
<p>Or use the following command:</p>
<pre class="language-bash"><code class="language-bash">dart pub add rdf_mapper
</code></pre>
<h2 id="-quick-start">üöÄ Quick Start</h2>
<h3 id="basic-setup">Basic Setup</h3>
<pre class="language-dart"><code class="language-dart">import 'package:rdf_mapper/rdf_mapper.dart';

// Create a mapper instance with default registry
final rdfMapper = RdfMapper.withDefaultRegistry();
</code></pre>
<h3 id="serialization">Serialization</h3>
<pre class="language-dart"><code class="language-dart">// Register the mapper
rdfMapper.registerMapper&lt;Person&gt;(PersonMapper());

// Serialize an object
final person = Person(
  id: 'http://example.org/person/1',
  name: 'John Smith',
  age: 30,
);

final turtle = rdfMapper.encodeObject(person);
print(turtle);
</code></pre>
<h3 id="deserialization">Deserialization</h3>
<pre class="language-dart"><code class="language-dart">// RDF Turtle input
final turtleInput = '''
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

&lt;http://example.org/person/1&gt; a foaf:Person ;
  foaf:name "John Smith" ;
  foaf:age 30 .
''';

// Deserialize an object
final person = rdfMapper.decodeObject&lt;Person&gt;(turtleInput);
print('Name: ${person.name}, Age: ${person.age}');
</code></pre>
<h3 id="model-and-mapper-classes-for-above-examples">Model and Mapper classes for above examples</h3>
<pre class="language-dart"><code class="language-dart">import 'package:rdf_vocabularies/schema.dart';

// Define a model class.
// You can define them as you like, there is no requirement for immutability or such
class Person {
  final String id;
  final String name;
  final int age;
  
  Person({required this.id, required this.name, required this.age});
}

// Create a custom mapper
class PersonMapper implements GlobalResourceMapper&lt;Person&gt; {
  @override
  IriTerm? get typeIri =&gt; SchemaPerson.classIri;
  
  @override
  (IriTerm, List&lt;Triple&gt;) toRdfResource(Person value, SerializationContext context, {RdfSubject? parentSubject}) {

    // convert dart objects to triples using the fluent builder API
    return context.resourceBuilder(IriTerm(value.id))
      .addValue(SchemaPerson.foafName, value.name)
      .addValue(SchemaPerson.foafAge, value.age)
      .build();
  }
  
  @override
  Person fromRdfResource(IriTerm term, DeserializationContext context) {
    final reader = context.reader(term);
    
    return Person(
      id: term.iri,
      name: reader.require&lt;String&gt;(SchemaPerson.foafName),
      age: reader.require&lt;int&gt;(SchemaPerson.foafAge),
    );
  }
}
</code></pre>
<h2 id="-zero-boilerplate-code-generation">üî• Zero-Boilerplate Code Generation</h2>
<p><strong>Want to eliminate all that mapper boilerplate?</strong> Use our code generation approach for the ultimate developer experience:</p>
<h3 id="1-add-dependencies">1. Add dependencies:</h3>
<pre class="language-sh"><code class="language-sh">dart pub add rdf_mapper rdf_mapper_annotations
dart pub add rdf_mapper_generator build_runner --dev
</code></pre>
<h3 id="2-annotate-your-classes">2. Annotate your classes:</h3>
<pre class="language-dart"><code class="language-dart">import 'package:rdf_mapper_annotations/rdf_mapper_annotations.dart';
import 'package:rdf_vocabularies/schema.dart';

@RdfGlobalResource(
  SchemaPerson.classIri,
  IriStrategy('http://example.org/person/{id}'),
)
class Person {
  @RdfIriPart('id')
  final String id;

  @RdfProperty(SchemaPerson.foafName)
  final String name;

  @RdfProperty(SchemaPerson.foafAge)
  final int age;

  Person({required this.id, required this.name, required this.age});
}
</code></pre>
<h3 id="3-generate-mappers">3. Generate mappers:</h3>
<pre class="language-bash"><code class="language-bash">dart run build_runner build
</code></pre>
<h3 id="4-use-your-generated-mappers">4. Use your generated mappers:</h3>
<pre class="language-dart"><code class="language-dart">// Initialize the mapper system (auto-generated)
final mapper = initRdfMapper();

// Use exactly like the manual approach - same API!
final person = Person(id: '1', name: 'John Smith', age: 30);
final turtle = mapper.encodeObject(person);
final deserializedPerson = mapper.decodeObject&lt;Person&gt;(turtle);
</code></pre>
<p><strong>That's it!</strong> No manual mapping code, no runtime reflection, just pure generated performance.</p>
<p><strong>Key Benefits:</strong></p>
<ul>
<li>üî• <strong>Zero boilerplate</strong> - Write business logic, not serialization code</li>
<li>üõ°Ô∏è <strong>Type safety</strong> - Compile-time guarantees for your RDF mappings</li>
<li>‚ö° <strong>Performance</strong> - Generated code with no runtime overhead</li>
<li>üéØ <strong>Schema.org support</strong> - Works seamlessly with rdf_vocabularies</li>
<li>üîß <strong>Flexible mapping</strong> - Custom mappers, IRI templates, complex relationships</li>
</ul>
<p>Learn more: <a href="https://kkalass.github.io/rdf_mapper_generator/">rdf_mapper_generator documentation</a></p>
<h2 id="architecture">Architecture</h2>
<p>The library is built around several core concepts:</p>
<h3 id="mapper-hierarchy">Mapper Hierarchy</h3>
<ul>
<li>
<p><strong>Term Mappers</strong>: For simple values (IRI terms or literals)</p>
<ul>
<li><code>IriTermMapper</code>: For IRIs (e.g., URIs, URLs)</li>
<li><code>LiteralTermMapper</code>: For literal values (strings, numbers, dates)</li>
</ul>
</li>
<li>
<p><strong>Resource Mappers</strong>: For complex objects with multiple properties</p>
<ul>
<li><code>GlobalResourceMapper</code>: For objects with globally unique identifiers</li>
<li><code>LocalResourceMapper</code>: For anonymous objects or auxiliary structures</li>
</ul>
</li>
</ul>
<h3 id="context-classes">Context Classes</h3>
<ul>
<li><code>SerializationContext</code>: Provides access to the ResourceBuilder</li>
<li><code>DeserializationContext</code>: Provides access to the ResourceReader</li>
</ul>
<h3 id="fluent-apis">Fluent APIs</h3>
<ul>
<li><code>ResourceBuilder</code>: For conveniently creating RDF resources with a fluent API</li>
<li><code>ResourceReader</code>: For easily accessing RDF resource properties</li>
</ul>
<h2 id="advanced-usage">Advanced Usage</h2>
<h3 id="working-with-graphs">Working with Graphs</h3>
<p>Working directly with RDF graphs (instead of strings):</p>
<pre class="language-dart"><code class="language-dart">// Graph-based serialization
final graph = rdfMapper.graph.encodeObject(person);

// Graph-based deserialization
final personFromGraph = rdfMapper.graph.decodeObject&lt;Person&gt;(graph);
</code></pre>
<h3 id="deserializing-multiple-objects">Deserializing Multiple Objects</h3>
<pre class="language-dart"><code class="language-dart">// Deserialize all objects in a graph
final objects = rdfMapper.decodeObjects(turtleInput);

// Only objects of a specific type
final people = rdfMapper.decodeObjects&lt;Person&gt;(turtleInput);
</code></pre>
<h3 id="temporary-mapper-registration">Temporary Mapper Registration</h3>
<pre class="language-dart"><code class="language-dart">// Temporary mapper for a single operation
final result = rdfMapper.decodeObject&lt;CustomType&gt;(
  input, 
  register: (registry) {
    registry.registerMapper&lt;CustomType&gt;(CustomTypeMapper());
  },
);
</code></pre>
<h3 id="namespace-helper-class">Namespace Helper Class</h3>
<p>For clean management of IRIs in RDF, we have <a href="https://kkalass.github.io/rdf_vocabularies/">rdf_vocabularies</a> which provides constants for the most common vocabularies.</p>
<p>In addition, if you have your own vocabulary and would like such a helper class generated, you may use <a href="https://kkalass.github.io/rdf_vocabulary_to_dart/">rdf_vocabulary_to_dart</a> which provides a build_runner for generating dart constants from rdf vocabulary files. It supports all serializations that rdf_core supports (turtle, jsonld, n-triple and also rdf/xml).</p>
<p>But you can also use our Namespace helper class which might be usefull during development</p>
<pre class="language-dart"><code class="language-dart">
// Example usage:
final example = Namespace('http://example.com/my-new-vocab/');

// Usage:
builder.addValue(example('name'), 'Alice');  // Generates http://example.com/my-new-vocab/name
</code></pre>
<h3 id="complex-example">Complex Example</h3>
<p>The following example demonstrates handling complex models with relationships between objects and nested structures:</p>
<pre class="language-dart"><code class="language-dart">import 'package:rdf_core/rdf_core.dart';

import 'package:rdf_mapper/rdf_mapper.dart';
import 'package:rdf_vocabularies/schema.dart';

void main() {
  final rdf =
      // Create mapper with default registry
      RdfMapper.withDefaultRegistry()
        // Register our custom mappers
        ..registerMapper&lt;Book&gt;(BookMapper())
        ..registerMapper&lt;Chapter&gt;(ChapterMapper())
        ..registerMapper&lt;ISBN&gt;(ISBNMapper())
        ..registerMapper&lt;Rating&gt;(RatingMapper());

  // Create a book with chapters
  final book = Book(
    id: 'hobbit', // Now just the identifier, not the full IRI
    title: 'The Hobbit',
    author: 'J.R.R. Tolkien',
    published: DateTime(1937, 9, 21),
    isbn: ISBN('9780618260300'),
    rating: Rating(5),
    chapters: [
      Chapter('An Unexpected Party', 1),
      Chapter('Roast Mutton', 2),
      Chapter('A Short Rest', 3),
    ],
  );

  // Convert the book to RDF Turtle codec
  final turtle = rdf.encodeObject(book);

  // Print the resulting Turtle representation
  final expectedTurtle = '''
@prefix book: &lt;http://example.org/book/&gt; .
@prefix schema: &lt;https://schema.org/&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

book:hobbit a schema:Book;
    schema:aggregateRating 5;
    schema:author "J.R.R. Tolkien";
    schema:datePublished "1937-09-20T23:00:00.000Z"^^xsd:dateTime;
    schema:hasPart [ a schema:Chapter ; schema:name "An Unexpected Party" ; schema:position 1 ], [ a schema:Chapter ; schema:name "Roast Mutton" ; schema:position 2 ], [ a schema:Chapter ; schema:name "A Short Rest" ; schema:position 3 ];
    schema:isbn &lt;urn:isbn:9780618260300&gt;;
    schema:name "The Hobbit" .
  ''';

  print('Book as RDF Turtle:');
  print(turtle);
  assert(turtle.trim() == expectedTurtle.trim());
}

// --- Domain Model ---

// Primary entity with an identifier that will be part of the IRI
class Book {
  final String id;
  final String title;
  final String author;
  final DateTime published;
  final ISBN isbn;
  final Rating rating;
  final Iterable&lt;Chapter&gt; chapters;

  Book({
    required this.id,
    required this.title,
    required this.author,
    required this.published,
    required this.isbn,
    required this.rating,
    required this.chapters,
  });
}

// Value object using blank nodes (no identifier)
class Chapter {
  final String title;
  final int number;

  Chapter(this.title, this.number);
}

// Custom identifier type using IRI mapping
class ISBN {
  final String value;

  ISBN(this.value);

  @override
  String toString() =&gt; value;
}

// Custom value type using literal mapping
class Rating {
  final int stars;

  Rating(this.stars) {
    if (stars &lt; 0 || stars &gt; 5) {
      throw ArgumentError('Rating must be between 0 and 5 stars');
    }
  }

  @override
  String toString() =&gt; '$stars stars';
}

// --- Mappers ---

// IRI-based entity mapper
class BookMapper implements GlobalResourceMapper&lt;Book&gt; {
  static final titlePredicate = SchemaBook.name;
  static final authorPredicate = SchemaBook.author;
  static final publishedPredicate = SchemaBook.datePublished;
  static final isbnPredicate = SchemaBook.isbn;
  static final ratingPredicate = SchemaBook.aggregateRating;
  static final chapterPredicate = SchemaBook.hasPart;

  // Base IRI prefix for book resources
  static const String bookIriPrefix = 'http://example.org/book/';

  @override
  final IriTerm typeIri = SchemaBook.classIri;

  /// Converts an ID to a full IRI
  String _createIriFromId(String id) =&gt; '$bookIriPrefix$id';

  /// Extracts the identifier from a full IRI
  String _extractIdFromIri(String iri) {
    if (!iri.startsWith(bookIriPrefix)) {
      throw ArgumentError('Invalid Book IRI format: $iri');
    }
    return iri.substring(bookIriPrefix.length);
  }

  @override
  Book fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    return Book(
      // Extract just the identifier part from the IRI
      id: _extractIdFromIri(subject.iri),
      title: reader.require&lt;String&gt;(titlePredicate),
      author: reader.require&lt;String&gt;(authorPredicate),
      published: reader.require&lt;DateTime&gt;(publishedPredicate),
      isbn: reader.require&lt;ISBN&gt;(isbnPredicate),
      rating: reader.require&lt;Rating&gt;(ratingPredicate),
      chapters: reader.getValues&lt;Chapter&gt;(chapterPredicate),
    );
  }

  @override
  (IriTerm, List&lt;Triple&gt;) toRdfResource(
    Book book,
    SerializationContext context, {
    RdfSubject? parentSubject,
  }) {
    return context
        .resourceBuilder(IriTerm(_createIriFromId(book.id)))
        .addValue(titlePredicate, book.title)
        .addValue(authorPredicate, book.author)
        .addValue&lt;DateTime&gt;(publishedPredicate, book.published)
        .addValue&lt;ISBN&gt;(isbnPredicate, book.isbn)
        .addValue&lt;Rating&gt;(ratingPredicate, book.rating)
        .addValues(chapterPredicate, book.chapters)
        .build();
  }
}

// Blank node-based entity mapper
class ChapterMapper implements LocalResourceMapper&lt;Chapter&gt; {
  static final titlePredicate = SchemaChapter.name;
  static final numberPredicate = SchemaChapter.position;

  @override
  final IriTerm typeIri = SchemaChapter.classIri;

  @override
  Chapter fromRdfResource(BlankNodeTerm term, DeserializationContext context) {
    final reader = context.reader(term);
    return Chapter(
      reader.require&lt;String&gt;(titlePredicate),
      reader.require&lt;int&gt;(numberPredicate),
    );
  }

  @override
  (BlankNodeTerm, List&lt;Triple&gt;) toRdfResource(
    Chapter chapter,
    SerializationContext ctxt, {
    RdfSubject? parentSubject,
  }) {
    return ctxt
        .resourceBuilder(BlankNodeTerm())
        .addValue(titlePredicate, chapter.title)
        .addValue&lt;int&gt;(numberPredicate, chapter.number)
        .build();
  }
}

// Custom IRI mapper
class ISBNMapper implements IriTermMapper&lt;ISBN&gt; {
  static const String isbnUriPrefix = 'urn:isbn:';

  @override
  IriTerm toRdfTerm(ISBN isbn, SerializationContext context) {
    return IriTerm('$isbnUriPrefix${isbn.value}');
  }

  @override
  ISBN fromRdfTerm(IriTerm term, DeserializationContext context) {
    final uri = term.iri;
    if (!uri.startsWith(isbnUriPrefix)) {
      throw ArgumentError('Invalid ISBN URI format: $uri');
    }
    return ISBN(uri.substring(isbnUriPrefix.length));
  }
}

// Custom literal mapper
class RatingMapper implements LiteralTermMapper&lt;Rating&gt; {
  @override
  LiteralTerm toRdfTerm(Rating rating, SerializationContext context) {
    return LiteralTerm.typed(rating.stars.toString(), 'integer');
  }

  @override
  Rating fromRdfTerm(LiteralTerm term, DeserializationContext context) {
    return Rating(int.parse(term.value));
  }
}
</code></pre>
<h3 id="lossless-mapping---preserve-all-your-data">Lossless Mapping - Preserve All Your Data</h3>
<p>Want to ensure no RDF data is lost during conversion? rdf_mapper provides powerful lossless mapping features:</p>
<pre class="language-dart"><code class="language-dart">// Decode with remainder - get your object plus any unmapped data
final (person, remainderGraph) = rdfMapper.decodeObjectLossless&lt;Person&gt;(turtle);

// Your object contains all mapped properties
print(person.name); // "John Smith"

// remainderGraph contains any triples that weren't part of your object
print('Preserved ${remainderGraph.triples.length} unmapped triples');

// Encode back to preserve everything
final restoredTurtle = rdfMapper.encodeObjectLossless((person, remainderGraph));
// Now you have the complete original data back!
</code></pre>
<p><strong>Preserve unmapped properties within objects:</strong></p>
<p>Using annotations with code generation (recommended):</p>
<pre class="language-dart"><code class="language-dart">@RdfGlobalResource(SchemaPerson.classIri, IriStrategy('http://example.org/person/{id}'))
class Person {
  @RdfIriPart('id')
  final String id;
  
  @RdfProperty(SchemaPerson.foafName)
  final String name;
  
  @RdfUnmappedTriples()
  final RdfGraph unmappedGraph; // Automatically captures unmapped properties
  
  Person({required this.id, required this.name, RdfGraph? unmappedGraph})
    : unmappedGraph = unmappedGraph ?? RdfGraph();
}
// Run: dart run build_runner build
// That's it! The generator creates the mapper automatically.
</code></pre>
<p>Manual implementation:</p>
<pre class="language-dart"><code class="language-dart">class Person {
  final String id;
  final String name;
  final RdfGraph unmappedGraph; // Catches unmapped properties
  
  Person({required this.id, required this.name, RdfGraph? unmappedGraph})
    : unmappedGraph = unmappedGraph ?? RdfGraph();
}

class PersonMapper implements GlobalResourceMapper&lt;Person&gt; {
  @override
  Person fromRdfResource(IriTerm subject, DeserializationContext context) {
    final reader = context.reader(subject);
    return Person(
      id: subject.iri,
      name: reader.require&lt;String&gt;(foafName),
      unmappedGraph: reader.getUnmapped&lt;RdfGraph&gt;(), // Captures unmapped data, should be the last reader call
    );
  }

  @override
  (IriTerm, List&lt;Triple&gt;) toRdfResource(Person person, SerializationContext context, {RdfSubject? parentSubject}) {
    return context.resourceBuilder(IriTerm(person.id))
      .addValue(foafName, person.name)
      .addUnmapped(person.unmappedGraph) // Restores unmapped data
      .build();
  }
}
</code></pre>
<p>Perfect for applications that need to preserve unknown properties, support evolving schemas, or maintain complete data fidelity.</p>
<p><strong>Alternative unmapped types:</strong> You can also use <code>Map&lt;IriTerm, List&lt;RdfObject&gt;&gt;</code> or <code>Map&lt;RdfPredicate, List&lt;RdfObject&gt;&gt;</code> for simpler, shallow unmapped data handling (without nested blank node triples).</p>
<p>See the <a href="doc/LOSSLESS_MAPPING.md">Lossless Mapping Guide</a> for complete details.</p>
<h2 id="supported-rdf-types">Supported RDF Types</h2>
<p>The library includes built-in mappers for common Dart types:</p>
<table>
<thead>
<tr>
<th>Dart Type</th>
<th>RDF Datatype</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>String</code></td>
<td>xsd:string</td>
</tr>
<tr>
<td><code>int</code></td>
<td>xsd:integer</td>
</tr>
<tr>
<td><code>double</code></td>
<td>xsd:decimal</td>
</tr>
<tr>
<td><code>bool</code></td>
<td>xsd:boolean</td>
</tr>
<tr>
<td><code>DateTime</code></td>
<td>xsd:dateTime</td>
</tr>
<tr>
<td><code>Uri</code></td>
<td>IRI</td>
</tr>
</tbody>
</table>
<h2 id="-datatype-handling-and-best-practices">üéØ Datatype Handling and Best Practices</h2>
<h3 id="understanding-datatype-strictness">Understanding Datatype Strictness</h3>
<p>RDF Mapper enforces <strong>datatype strictness</strong> by default to ensure:</p>
<ul>
<li><strong>Roundtrip Consistency</strong>: Values serialize back to the same RDF datatype</li>
<li><strong>Semantic Preservation</strong>: Original meaning is maintained across transformations</li>
<li><strong>Data Integrity</strong>: Prevention of data corruption in RDF stores</li>
</ul>
<h3 id="common-datatype-scenarios">Common Datatype Scenarios</h3>
<h4 id="working-with-standard-types">Working with Standard Types</h4>
<pre class="language-dart"><code class="language-dart">// These work out of the box
final person = Person(
  name: "Alice",        // -&gt; xsd:string
  age: 30,              // -&gt; xsd:integer  
  height: 1.75,         // -&gt; xsd:decimal
  isActive: true,       // -&gt; xsd:boolean
  birthDate: DateTime.now(), // -&gt; xsd:dateTime
);
</code></pre>
<h4 id="handling-non-standard-datatypes">Handling Non-Standard Datatypes</h4>
<p>When your RDF data uses different datatypes than the defaults:</p>
<pre class="language-turtle"><code class="language-turtle"># RDF data with non-standard datatypes
ex:temperature "23.5"^^units:celsius .
ex:weight "70.5"^^units:kilogram .
ex:score "95.0"^^xsd:double .  # double instead of decimal
</code></pre>
<p><strong>Solution 1: Custom Wrapper Types (Recommended)</strong></p>
<pre class="language-dart"><code class="language-dart">@RdfLiteral(IriTerm('http://qudt.org/vocab/unit/CEL'))
class Temperature {
  @RdfValue()
  final double celsius;
  const Temperature(this.celsius);
}

// Or manual implementation
class Weight {
  final double kilograms;
  const Weight(this.kilograms);
}

class WeightMapper extends DelegatingRdfLiteralTermMapper&lt;Weight, double&gt; {
  static final kgDatatype = IriTerm('http://qudt.org/vocab/unit/KiloGM');
  
  const WeightMapper() : super(const DoubleMapper(), kgDatatype);
  
  @override
  Weight convertFrom(double value) =&gt; Weight(value);
  
  @override  
  double convertTo(Weight value) =&gt; value.kilograms;
}
</code></pre>
<p><strong>Solution 2: Global Registration</strong></p>
<pre class="language-dart"><code class="language-dart">// For existing types with different datatypes
final rdfMapper = RdfMapper.withMappers((registry) =&gt; registry
  ..registerMapper&lt;double&gt;(DoubleMapper(Xsd.double))  // Use xsd:double
  ..registerMapper&lt;Temperature&gt;(TemperatureMapper())
  ..registerMapper&lt;Weight&gt;(WeightMapper()));
</code></pre>
<p><strong>Solution 3: Local Scope Override</strong></p>
<pre class="language-dart"><code class="language-dart">// For specific predicates only - simpler option
@RdfProperty('http://example.org/score',
             literal: const LiteralMapping.withType(Xsd.double))
double? testScore;

// Alternative: mapper instance approach
@RdfProperty('http://example.org/score',
             literal: LiteralMapping.mapperInstance(DoubleMapper(Xsd.double)))
double? testScore;
</code></pre>
<h3 id="troubleshooting-datatype-issues">Troubleshooting Datatype Issues</h3>
<p>When you see <code>DeserializerDatatypeMismatchException</code>:</p>
<ol>
<li><strong>Identify the mismatch</strong>: The exception shows actual vs expected datatypes</li>
<li><strong>Choose your strategy</strong>: Global, wrapper type, or local scope solution</li>
<li><strong>Implement the fix</strong>: Use the code examples provided in the exception message</li>
<li><strong>Test roundtrip</strong>: Ensure serialize ‚Üí deserialize produces identical results</li>
</ol>
<h3 id="performance-tips">Performance Tips</h3>
<ul>
<li>Use <code>const</code> constructors for mappers when possible</li>
<li>Prefer wrapper types over global overrides for better type safety</li>
<li>Consider caching for expensive custom conversions</li>
<li>Use <code>bypassDatatypeCheck</code> sparingly and only when necessary</li>
</ul>
<h2 id="-error-handling">‚ö†Ô∏è Error Handling</h2>
<p>RDF Mapper provides specific exceptions to help diagnose mapping issues:</p>
<ul>
<li><code>RdfMappingException</code>: Base exception for all mapping errors</li>
<li><code>SerializationException</code>: Errors during serialization</li>
<li><code>DeserializationException</code>: Errors during deserialization</li>
<li><code>SerializerNotFoundException</code>: When no serializer is registered for a type</li>
<li><code>DeserializerNotFoundException</code>: When no deserializer is registered for a type</li>
<li><code>PropertyValueNotFoundException</code>: When a required property is missing</li>
<li><code>TooManyPropertyValuesException</code>: When multiple values exist for a single-valued property</li>
<li><code>DeserializerDatatypeMismatchException</code>: When RDF datatype doesn't match expected type</li>
</ul>
<h3 id="handling-datatype-mismatches">Handling Datatype Mismatches</h3>
<p>The library enforces <strong>datatype strictness</strong> to ensure roundtrip consistency and semantic preservation. When you encounter a <code>DeserializerDatatypeMismatchException</code>, you have several resolution options:</p>
<h4 id="global-solution-affects-all-instances">Global Solution (affects all instances)</h4>
<pre class="language-dart"><code class="language-dart">// Register a mapper for the encountered datatype
final rdfMapper = RdfMapper.withMappers((registry) =&gt; 
  registry.registerMapper&lt;double&gt;(DoubleMapper(Xsd.double)));
</code></pre>
<h4 id="custom-wrapper-types-recommended">Custom Wrapper Types (recommended)</h4>
<pre class="language-dart"><code class="language-dart">// Using annotations
@RdfLiteral(Xsd.double)
class MyCustomDouble {
  @RdfValue()
  final double value;
  const MyCustomDouble(this.value);
}

// Manual implementation
class MyCustomDouble {
  final double value;
  const MyCustomDouble(this.value);
}

class MyCustomDoubleMapper extends DelegatingRdfLiteralTermMapper&lt;MyCustomDouble, double&gt; {
  const MyCustomDoubleMapper() : super(const DoubleMapper(), Xsd.double);
  
  @override
  MyCustomDouble convertFrom(double value) =&gt; MyCustomDouble(value);
  
  @override
  double convertTo(MyCustomDouble value) =&gt; value.value;
}
</code></pre>
<h4 id="local-scope-for-specific-predicates">Local Scope (for specific predicates)</h4>
<pre class="language-dart"><code class="language-dart">// In custom resource mappers
reader.require(myPredicate, literalTermDeserializer: DoubleMapper(Xsd.double));

// With annotations - simpler option
@RdfProperty(myPredicate, 
             literal: const LiteralMapping.withType(Xsd.double))

// With annotations - mapper instance approach
@RdfProperty(myPredicate, 
             literal: LiteralMapping.mapperInstance(DoubleMapper(Xsd.double)))
</code></pre>
<h4 id="bypass-option-use-carefully">Bypass Option (use carefully)</h4>
<pre class="language-dart"><code class="language-dart">// Only when flexible datatype handling is required
context.fromLiteralTerm(term, bypassDatatypeCheck: true);
</code></pre>
<h2 id="-performance-considerations">üö¶ Performance Considerations</h2>
<ul>
<li>RDF Mapper uses efficient traversal algorithms for both serialization and deserialization</li>
<li>For large graphs, consider using the graph-based API instead of string serialization</li>
<li>Consider implementing custom mappers for performance-critical types in your application</li>
</ul>
<h2 id="-roadmap--next-steps">üõ£Ô∏è Roadmap / Next Steps</h2>
<ul>
<li>Detect cycles, optimally support them.</li>
<li>Properly Support Collection (<code>rdf:first</code> / <code>rdf:rest</code> / <code>rdf:nil</code> pattern) for serialization and derserialization as dart List.</li>
<li>Support mapping to / from multiple RDF classes (e.g. schema:Person and foaf:Person)</li>
<li>Improve test coverage</li>
</ul>
<h2 id="-contributing">ü§ù Contributing</h2>
<p>Contributions, bug reports, and feature requests are welcome!</p>
<ul>
<li>Fork the repo and submit a PR</li>
<li>See <a href="CONTRIBUTING.md">CONTRIBUTING.md</a> for guidelines</li>
<li>Join the discussion in <a href="https://github.com/kkalass/rdf_mapper/issues">GitHub Issues</a></li>
</ul>
<h2 id="-ai-policy">ü§ñ AI Policy</h2>
<p>This project is proudly human-led and human-controlled, with all key decisions, design, and code reviews made by people. At the same time, it stands on the shoulders of LLM giants: generative AI tools are used throughout the development process to accelerate iteration, inspire new ideas, and improve documentation quality. We believe that combining human expertise with the best of AI leads to higher-quality, more innovative open source software.</p>
<hr>
<p>¬© 2025 Klas Kala√ü. Licensed under the MIT License.</p>
</section>


      <section class="summary">
          <h2>Libraries</h2>
        <dl>
          <dt id="rdf_mapper">
  <span class="name"><a href="rdf_mapper/">rdf_mapper</a></span> 

</dt>
<dd>RDF Mapping Library for Dart
</dd>

        </dl>
      </section>
  </div> <!-- /.main-content -->
  <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
    <!-- The search input and breadcrumbs below are only responsively visible at low resolutions. -->
<header id="header-search-sidebar" class="hidden-l">
  <form class="search-sidebar" role="search">
    <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>
<ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
    <li><a href="https://kkalass.github.io/rdf_mapper/">rdf_mapper package</a></li>
</ol>

    <h5 class="hidden-xs"><span class="package-name">rdf_mapper</span> <span class="package-kind">package</span></h5>
    <ol>
      <li class="section-title">Libraries</li>
      <li><a href="rdf_mapper/">rdf_mapper</a></li>
</ol>

  </div>
  <div id="dartdoc-sidebar-right" class="sidebar sidebar-offcanvas-right">
  </div>
</main>
<footer>
  <span class="no-break">
    rdf_mapper
      0.8.8
  </span>
  
</footer>


<script src="static-assets/highlight.pack.js?v1"></script>
<script src="static-assets/docs.dart.js"></script>

</body>
</html>

